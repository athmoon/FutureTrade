#include <iostream>
#include <windows.h>
#include "Trader.h"
#include <assert.h>

#pragma comment(lib,"Api\\thosttraderapi.lib")

#pragma warning(disable : 4099)

TThostFtdcInstrumentIDType CloseToday[32] ={"rb","ag"};


CtpTraderSpi::CtpTraderSpi(struct user_config* cfg):m_cfg(cfg)
{ 
	requestId = 0; 
	m_bUpdatePositionList = false;
};

CtpTraderSpi::~CtpTraderSpi()
{ 
	pUserApi->Release(); 
};

bool CtpTraderSpi::IsErrorRspInfo(CThostFtdcRspInfoField *pRspInfo)
{
	// 如果ErrorID != 0, 说明收到了错误的响应
	bool ret = ((pRspInfo) && (pRspInfo->ErrorID != 0));
	if (ret){
		cerr<<" 响应 | "<<pRspInfo->ErrorMsg<<endl;
	}
	return ret;
}

void CtpTraderSpi::OnRspError(CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast)
{
	IsErrorRspInfo(pRspInfo);
}

void CtpTraderSpi::OnHeartBeatWarning(int nTimeLapse)
{
	cerr<<" 响应 | 心跳超时警告..." 
		<< " TimerLapse = " << nTimeLapse << endl;
}



void CtpTraderSpi::OnFrontConnected()
{
	cerr<<" 连接交易前置...成功"<<endl;
	SetEvent(g_hEvent);
}

void CtpTraderSpi::OnFrontDisconnected(int nReason)
{
	cerr<<" 响应 | 连接中断..." 
		<< " reason=" << nReason << endl;
}

void CtpTraderSpi::ReqUserLogin(TThostFtdcBrokerIDType	vAppId,
								TThostFtdcUserIDType	vUserId,	TThostFtdcPasswordType	vPasswd)
{

	CThostFtdcReqUserLoginField userLogin;
	memset(&userLogin, 0, sizeof(userLogin));
	strcpy(userLogin.BrokerID, vAppId); 
	strcpy(userLogin.UserID, vUserId);  
	strcpy(userLogin.Password, vPasswd);


	int ret = pUserApi->ReqUserLogin(&userLogin, requestId++);
	cerr<<" 请求 | 发送登录..."<<((ret == 0) ? "成功" :"失败") << endl;	
}

void CtpTraderSpi::OnRspUserLogin(CThostFtdcRspUserLoginField *pRspUserLogin,
								  CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast)
{
	if ( pRspUserLogin ) {  
		// 保存会话参数	
		RspUserInfo.frontId = pRspUserLogin->FrontID;
		RspUserInfo.sessionId = pRspUserLogin->SessionID;
		int nextOrderRef = atoi(pRspUserLogin->MaxOrderRef);
		sprintf(RspUserInfo.orderRef, "%d", ++nextOrderRef);
		cerr<<" 响应 | 登录成功...当前交易日:"
			<<pRspUserLogin->TradingDay<<endl; 
		
		strcpy(TradeDate,pRspUserLogin->TradingDay);
	}
	if(bIsLast) SetEvent(g_hEvent);
}

void CtpTraderSpi::ReqSettlementInfoConfirm()
{
	CThostFtdcSettlementInfoConfirmField req;
	memset(&req, 0, sizeof(req));
	strcpy(req.BrokerID, m_cfg->brokerID.c_str());
	strcpy(req.InvestorID, m_cfg->userID.c_str());


	int ret = pUserApi->ReqSettlementInfoConfirm(&req, ++requestId);
	cerr<<" 请求 | 发送结算单确认..."<<((ret == 0)?"成功":"失败")<<endl;
}


void CtpTraderSpi::OnRspSettlementInfoConfirm(
	CThostFtdcSettlementInfoConfirmField  *pSettlementInfoConfirm, 
	CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast)
{	
	if( pSettlementInfoConfirm){
		cerr<<" 响应 | 结算单..."<<pSettlementInfoConfirm->InvestorID
			<<"...<"<<pSettlementInfoConfirm->ConfirmDate
			<<" "<<pSettlementInfoConfirm->ConfirmTime<<">...确认"<<endl;
	}
	if(bIsLast) 
		SetEvent(g_hEvent);
}

void CtpTraderSpi::UserLogin()
{

	ReqUserLogin((char*)m_cfg->brokerID.c_str(),(char*)m_cfg->userID.c_str(),(char*)m_cfg->passwd.c_str());
	WaitForSingleObject(g_hEvent,INFINITE);
	ResetEvent(g_hEvent);

	Sleep(SLEEP_TIME);


	ReqSettlementInfoConfirm();
	WaitForSingleObject(g_hEvent,INFINITE);
	ResetEvent(g_hEvent);
	Sleep(SLEEP_TIME);

}


void CtpTraderSpi::ReqQryTradingAccount()
{
	CThostFtdcQryTradingAccountField req;
	memset(&req, 0, sizeof(req));
	strcpy(req.BrokerID, m_cfg->brokerID.c_str());
	strcpy(req.InvestorID, m_cfg->userID.c_str());
	int ret = pUserApi->ReqQryTradingAccount(&req, ++requestId);
	cerr<<" 请求 | 发送资金查询..."<<((ret == 0)?"成功":"失败")<<endl;

}

void CtpTraderSpi::OnRspQryTradingAccount(
	CThostFtdcTradingAccountField *pTradingAccount, 
	CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast)
{ 
	if (pTradingAccount){
		cerr<<" 响应 | 权益:"<<pTradingAccount->Balance
			<<" 可用:"<<pTradingAccount->Available   
			<<" 保证金:"<<pTradingAccount->CurrMargin
			<<" 平仓盈亏:"<<pTradingAccount->CloseProfit
			<<" 持仓盈亏"<<pTradingAccount->PositionProfit
			<<" 手续费:"<<pTradingAccount->Commission
			<<" 冻结保证金:"<<pTradingAccount->FrozenMargin
			//<<" 冻结手续费:"<<pTradingAccount->FrozenCommission 
			<< endl;    
	}
	if(bIsLast) SetEvent(g_hEvent);
}

void CtpTraderSpi::ReqQryInstrument(TThostFtdcInstrumentIDType instId)
{
	CThostFtdcQryInstrumentField req;
	memset(&req, 0, sizeof(req));
	strcpy(req.InstrumentID, instId);
	int ret = pUserApi->ReqQryInstrument(&req, ++requestId);
	cerr<<" 请求 | 发送合约查询..."<<((ret == 0)?"成功":"失败")<<endl;
}

void CtpTraderSpi::OnRspQryInstrument(CThostFtdcInstrumentField *pInstrument, 
									  CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast)
{ 	
	if (pInstrument){
		cerr<<" 响应 | 合约:"<<pInstrument->InstrumentID
			<<" 交割月:"<<pInstrument->DeliveryMonth
			<<" 多头保证金率:"<<pInstrument->LongMarginRatio
			<<" 空头保证金率:"<<pInstrument->ShortMarginRatio<<endl;    
	}
	if(bIsLast) SetEvent(g_hEvent);
}

void CtpTraderSpi::ReqQryInvestorPosition(TThostFtdcInstrumentIDType instId)
{
	CThostFtdcQryInvestorPositionField req;
	memset(&req, 0, sizeof(req));
	strcpy(req.BrokerID, m_cfg->brokerID.c_str());
	strcpy(req.InvestorID, m_cfg->userID.c_str());
	strcpy(req.InstrumentID, instId);	
	int ret = pUserApi->ReqQryInvestorPosition(&req, ++requestId);
	cerr<<" 请求 | 发送持仓查询..."<<((ret == 0)?"成功":"失败")<<endl;
}




char CtpTraderSpi::MapDirection(char src, bool toOrig)
{
	if(toOrig)
	{
		if('b'==src||'B'==src)
		{src='0';}
		else if('s'==src||'S'==src)
		{src='1';}
	}
	else
	{
		if('0'==src)
		{src='B';}
		else if('1'==src)
		{src='S';}
	}
	return src;
}

char CtpTraderSpi::MapOffset(char src, bool toOrig)
{
	if(toOrig)
	{
		if('o'==src||'O'==src)
		{
			src='0';
		}
		else if('c'==src||'C'==src)
		{
			src='1';
		}
		else if('j'==src||'J'==src)
		{
			src='3';
		}
	}
	else
	{
		if('0'==src)
		{
			src='O';
		}
		else if('1'==src)
		{
			src='C';
		}
		else if('3'==src)
		{
			src='J';
		}
	}
	return src;
}


void CtpTraderSpi::OnRspQryInvestorPosition(
	CThostFtdcInvestorPositionField *pInvestorPosition, 
	CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast)
{ 
	if(pInvestorPosition ){
		cerr<<" 响应 | 合约:"<<pInvestorPosition->InstrumentID
			<<" 方向:"<<MapDirection(pInvestorPosition->PosiDirection)
			<<" 总持仓:"<<pInvestorPosition->Position
			<<" 昨仓:"<<pInvestorPosition->YdPosition 
			<<" 今仓:"<<pInvestorPosition->TodayPosition
			<<" 成本:"<<pInvestorPosition->OpenCost
			<<" 持仓盈亏:"<<pInvestorPosition->PositionProfit
			<<" 保证金:"<<pInvestorPosition->UseMargin<<endl;
	}
	if(bIsLast) 
		SetEvent(g_hEvent);	
}

int CtpTraderSpi::ReqQryInvestorPositionDetail(TThostFtdcInstrumentIDType instId)
{
	struct CThostFtdcQryInvestorPositionDetailField field;
	strcpy(field.BrokerID ,m_cfg->brokerID.c_str());
	strcpy(field.InvestorID,m_cfg->userID.c_str());
	strcpy(field.InstrumentID,"");

	if(instId)
	{
		strcpy(field.InstrumentID,instId);
	}
	int ret = pUserApi->ReqQryInvestorPositionDetail(&field, ++requestId);
	cerr<< " 请求 | 发送持仓查询..." <<((ret == 0)?"成功":"失败") << endl;
	return ret;

}

//only call once to update the postionList

void CtpTraderSpi::OnRspQryInvestorPositionDetail(CThostFtdcInvestorPositionDetailField *pInvestorPositionDetail, CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast)
{
	if (!IsErrorRspInfo(pRspInfo) && pInvestorPositionDetail)
	{
		cerr<< " 响应 | 查询持仓..."
			<< "合约代码:"<<pInvestorPositionDetail->InstrumentID
			<<" 买卖:"<<pInvestorPositionDetail->Direction
			<<"成交编号"<<pInvestorPositionDetail->TradeID
			<<"数量"<<pInvestorPositionDetail->Volume
			<<"开仓价"<<pInvestorPositionDetail->OpenPrice<<endl;

		struct PositionListItem field;
		field.Direction= pInvestorPositionDetail->Direction;
		strcpy(field.InstrumentID,pInvestorPositionDetail->InstrumentID);
		field.OpenPrice = pInvestorPositionDetail->OpenPrice;
		field.Volume = pInvestorPositionDetail->Volume;
		strcpy(field.OpenDate ,pInvestorPositionDetail->OpenDate);

		if(!m_bUpdatePositionList)
			UpdatePositionInfo(&field);

	}
	if(bIsLast) 
	{
		SetEvent(g_hEvent);	
		m_bUpdatePositionList = true;
	}
}

//OC_flag : open/close
void CtpTraderSpi::UpdatePositionInfo(struct PositionListItem *pInvestorPosition)
{
	struct PositionListItem field;
	memcpy(&field,pInvestorPosition,sizeof(struct PositionListItem));
	field.TradeNum =1;
	if(field.Volume==0)
		return;

	list<struct PositionListItem>::iterator iter = positionList.begin();
	for (; iter!=positionList.end(); iter++)
	{
		if (strcmp(iter->InstrumentID,pInvestorPosition->InstrumentID)==0 )
		{
			if(iter->Direction==pInvestorPosition->Direction)
			{
				iter->OpenPrice = (iter->OpenPrice+pInvestorPosition->OpenPrice)/2;
				iter->Volume++;
			}
			else
			{
				iter->Volume--;
				assert(iter->Volume>=0);
				if(iter->Volume==0)
					positionList.erase(iter);
				//iter->TradeNum++;
			}
			return;	
		}

	}

	positionList.push_back(field);
	m_bUpdatePositionList = false;

}


void CtpTraderSpi::ReqOrderInsert(TThostFtdcInstrumentIDType instId,
								  TThostFtdcDirectionType dir, TThostFtdcCombOffsetFlagType kpp,
								  TThostFtdcPriceType price,   TThostFtdcVolumeType vol, TThostFtdcPriceType deta)
{
	CThostFtdcInputOrderField req;
	memset(&req, 0, sizeof(req));	
	strcpy(req.BrokerID, m_cfg->brokerID.c_str());  	
	strcpy(req.InvestorID, m_cfg->userID.c_str()); 
	strcpy(req.InstrumentID, instId); 	
	strcpy(req.OrderRef, RspUserInfo.orderRef);  //报单引用
	int nextOrderRef = atoi(RspUserInfo.orderRef);
	sprintf(RspUserInfo.orderRef, "%d", ++nextOrderRef);

	req.OrderPriceType = THOST_FTDC_OPT_LimitPrice;//价格类型=限价	
	req.Direction = MapDirection(dir,true);  //买卖方向	
	req.CombOffsetFlag[0] = MapOffset(kpp[0],true); //THOST_FTDC_OF_Open; //组合开平标志:开仓
	req.CombHedgeFlag[0] = THOST_FTDC_HF_Speculation;	  //组合投机套保标志
	req.LimitPrice = price;	//价格
	req.VolumeTotalOriginal = vol;	///数量	
	req.TimeCondition = THOST_FTDC_TC_GFD;  //有效期类型:当日有效
	req.VolumeCondition = THOST_FTDC_VC_AV; //成交量类型:任何数量
	req.MinVolume = 1;	//最小成交量:1	
	req.ContingentCondition = THOST_FTDC_CC_Immediately;  //触发条件:立即

	TThostFtdcPriceType	StopPrice =price + deta ;  //止损价
	req.ForceCloseReason = THOST_FTDC_FCC_NotForceClose;	//强平原因:非强平	
	req.IsAutoSuspend = 0;  //自动挂起标志:否	
	req.UserForceClose = 0;   //用户强评标志:否

	int ret = pUserApi->ReqOrderInsert(&req, ++requestId);
	cerr<<" 请求 | 发送报单..."<<((ret == 0)?"成功":"失败")<< endl;
}

void CtpTraderSpi::OnRspOrderInsert(CThostFtdcInputOrderField *pInputOrder, 
									CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast)
{
	if( !IsErrorRspInfo(pRspInfo) && pInputOrder ){
		cerr<<"响应 | 报单提交成功...报单引用:"<<pInputOrder->OrderRef<<endl;  
	}
	if(bIsLast) SetEvent(g_hEvent);	
}


void CtpTraderSpi::ReqOrderAction(TThostFtdcSequenceNoType orderSeq)
{
	bool found=false; unsigned int i=0;
	for(i=0;i<orderList.size();i++){
		if(orderList[i]->BrokerOrderSeq == orderSeq){ found = true; break;}
	}
	if(!found){cerr<<" 请求 | 报单不存在."<<endl; return;} 

	CThostFtdcInputOrderActionField req;
	memset(&req, 0, sizeof(req));
	strcpy(req.BrokerID, m_cfg->brokerID.c_str());   
	strcpy(req.InvestorID, m_cfg->userID.c_str()); 
	strcpy(req.ExchangeID, orderList[i]->ExchangeID);
	strcpy(req.OrderSysID, orderList[i]->OrderSysID);
	req.ActionFlag = THOST_FTDC_AF_Delete;  

	int ret = pUserApi->ReqOrderAction(&req, ++requestId);
	cerr<< " 请求 | 发送撤单..." <<((ret == 0)?"成功":"失败") << endl;
}

void CtpTraderSpi::OnRspOrderAction(
									CThostFtdcInputOrderActionField *pInputOrderAction, 
									CThostFtdcRspInfoField *pRspInfo, int nRequestID, bool bIsLast)
{	
	if (!IsErrorRspInfo(pRspInfo) && pInputOrderAction){
		cerr<< " 响应 | 撤单成功..."
			<< "交易所:"<<pInputOrderAction->ExchangeID
			<<" 报单编号:"<<pInputOrderAction->OrderSysID<<endl;
	}
	if(bIsLast) SetEvent(g_hEvent);	
}

///报单回报
void CtpTraderSpi::OnRtnOrder(CThostFtdcOrderField *pOrder)
{	
	CThostFtdcOrderField* order = new CThostFtdcOrderField();
	memcpy(order,  pOrder, sizeof(CThostFtdcOrderField));
	bool founded=false; 
	unsigned int i=0;
	for(;i<orderList.size(); i++)
	{
		if(orderList[i]->BrokerOrderSeq == order->BrokerOrderSeq)
		{
			founded=true;   
			break;
		}
	}
	if(founded) 
		orderList[i]= order;   
	else  
		orderList.push_back(order);
	cerr<<" 回报 | 报单已提交...序号:"<<order->BrokerOrderSeq<<endl;
	BrokerOrderSeq = order->BrokerOrderSeq;
	SetEvent(g_hEvent);	
}


void CtpTraderSpi::PrintOrders(){
	CThostFtdcOrderField* pOrder; 
	for(unsigned int i=0; i<orderList.size(); i++)
	{
		pOrder = orderList[i];
		cerr<<" 报单 | 合约:"<<pOrder->InstrumentID
			<<" 方向:"<<MapDirection(pOrder->Direction,false)
			<<" 开平:"<<MapOffset(pOrder->CombOffsetFlag[0],false)
			<<" 价格:"<<pOrder->LimitPrice
			<<" 数量:"<<pOrder->VolumeTotalOriginal
			<<" 序号:"<<pOrder->BrokerOrderSeq 
			<<" 报单编号:"<<pOrder->OrderSysID
			<<" 状态:"<<pOrder->StatusMsg<<endl;
	}
	SetEvent(g_hEvent);
}


void CtpTraderSpi::PrintTrades(){
	CThostFtdcTradeField* pTrade;
	for(unsigned int i=0; i<tradeList.size(); i++)
	{
		pTrade = tradeList[i];
		cerr<<" 成交 | 合约:"<< pTrade->InstrumentID 
			<<" 方向:"<<MapDirection(pTrade->Direction,false)
			<<" 开平:"<<MapOffset(pTrade->OffsetFlag,false) 
			<<" 价格:"<<pTrade->Price
			<<" 数量:"<<pTrade->Volume
			<<" 报单编号:"<<pTrade->OrderSysID
			<<" 成交编号:"<<pTrade->TradeID<<endl;
	}
	SetEvent(g_hEvent);
}


///成交通知
void CtpTraderSpi::OnRtnTrade(CThostFtdcTradeField *pTrade)
{
	CThostFtdcTradeField* trade = new CThostFtdcTradeField();
	memcpy(trade,  pTrade, sizeof(CThostFtdcTradeField));
	bool founded=false;     
	unsigned int i=0;
	for(i=0; i<tradeList.size(); i++)
	{
		if(tradeList[i]->TradeID == trade->TradeID)
		{
			founded=true;  
			break;
		}
	}
	if(founded) 
		tradeList[i] = trade;   
	else  
		tradeList.push_back(trade);

	struct PositionListItem field;
	field.Direction=trade->Direction;
	strcpy(field.InstrumentID,trade->InstrumentID);
	field.OpenPrice = trade->Price;
	field.Volume = trade->Volume;
	field.OffsetFlag = trade->OffsetFlag;

	if(m_bUpdatePositionList)
		UpdatePositionInfo(&field);

	cerr<<" 回报 | 报单已成交...成交编号:"<<trade->TradeID<<endl;

	SetEvent(g_hEvent);
}

//not support buy and sell at the same position.
int CtpTraderSpi::LookupInstruments(TThostFtdcInstrumentIDType instId,struct PositionListItem& Inst)
{
	memset(&Inst,0,sizeof(struct PositionListItem));

	list<struct PositionListItem>::iterator iter = positionList.begin();
	for (; iter!=positionList.end(); iter++)
	{
		if (strcmp(iter->InstrumentID,instId)==0 )
		{
			Inst.Volume = iter->Volume;
			strcpy(Inst.InstrumentID, iter->InstrumentID);
			Inst.Direction = iter->Direction;
			Inst.OpenPrice = iter->OpenPrice;
			Inst.TradeNum = iter->TradeNum;
			strcpy(Inst.OpenDate,iter->OpenDate);
			return  1;
		}
	}

	return 0;

}
void CtpTraderSpi::Sleep_Wait(unsigned int time)
{
	Sleep(time);
	WaitForSingleObject(g_hEvent,INFINITE);
	ResetEvent(g_hEvent);
}

void CtpTraderSpi::StartToTrade()
{
	pUserApi = CThostFtdcTraderApi::CreateFtdcTraderApi(".\\flow_td\\");

	pUserApi->RegisterSpi(this);									// 注册事件类
	pUserApi->SubscribePublicTopic(THOST_TERT_RESUME);				// 注册公有流
	pUserApi->SubscribePrivateTopic(THOST_TERT_RESUME);			 // 注册私有流
	pUserApi->RegisterFront((char*)m_cfg->trade_addr.c_str());							// 注册交易前置地址

	pUserApi->Init();

	Sleep_Wait(SLEEP_TIME);

	ReqUserLogin((char*)m_cfg->brokerID.c_str(),(char*)m_cfg->userID.c_str(),(char*)m_cfg->passwd.c_str());

	Sleep_Wait(SLEEP_TIME);

	ReqSettlementInfoConfirm();

	Sleep_Wait(SLEEP_TIME);

	ReqQryTradingAccount(); 

	Sleep_Wait(SLEEP_TIME);

	ReqQryInvestorPositionDetail("");

	Sleep_Wait(SLEEP_TIME);
	
}

bool CtpTraderSpi::IsCloseTodayInst(TThostFtdcInstrumentIDType instId)
{
	//loop the closeToday inst list
	struct PositionListItem instPos;
	LookupInstruments(instId, instPos);
	string delims="1";
	string str=instId; 
	size_t pos = str.find_first_of(delims); 

	str = str.substr(0,pos);

	if(strcpy(instPos.OpenDate,TradeDate)==0)
	{
		for (int i =0; i<sizeof(CloseToday)/sizeof(TThostFtdcInstrumentIDType); i++)
		{
			if(strcpy((char*)str.c_str(),CloseToday[i])==0)
				return true;
		}
		return false;
	}
	else
		return false;
}

void CtpTraderSpi::Buy_Open(TThostFtdcInstrumentIDType instId,TThostFtdcPriceType price,TThostFtdcVolumeType vol/* =1 */,TThostFtdcPriceType loss /* =0 */)
{
	TThostFtdcDirectionType dir = THOST_FTDC_D_Buy;
	TThostFtdcCombOffsetFlagType kpp;
	kpp[0] = THOST_FTDC_OF_Open;
	//strcpy(kpp,THOST_FTDC_OF_Open);
	ReqOrderInsert(instId,dir,kpp,price,vol,loss);
}

void CtpTraderSpi::Sell_Close(TThostFtdcInstrumentIDType instId,TThostFtdcPriceType price,TThostFtdcVolumeType vol/* =1 */,TThostFtdcPriceType loss /* =0 */)
{
	TThostFtdcDirectionType dir = THOST_FTDC_D_Sell;
	TThostFtdcCombOffsetFlagType kpp;
	kpp[0]= THOST_FTDC_OF_Close;
	
	if(IsCloseTodayInst(instId))
		kpp[0] = THOST_FTDC_OF_CloseToday;
	ReqOrderInsert(instId,dir,kpp,price,vol,loss);
}

void CtpTraderSpi::Sell_Open(TThostFtdcInstrumentIDType instId,TThostFtdcPriceType price,TThostFtdcVolumeType vol/* =1 */,TThostFtdcPriceType loss /* =0 */)
{
	TThostFtdcDirectionType dir = THOST_FTDC_D_Sell;
	TThostFtdcCombOffsetFlagType kpp;
	kpp[0]= THOST_FTDC_OF_Open;
	ReqOrderInsert(instId,dir,kpp,price,vol,loss);
}

void CtpTraderSpi::Buy_Close(TThostFtdcInstrumentIDType instId,TThostFtdcPriceType price,TThostFtdcVolumeType vol/* =1 */,TThostFtdcPriceType loss /* =0 */)
{
	TThostFtdcDirectionType dir = THOST_FTDC_D_Buy;
	TThostFtdcCombOffsetFlagType kpp;
	kpp[0]= THOST_FTDC_OF_Close;

	if(IsCloseTodayInst(instId))
		kpp[0] = THOST_FTDC_OF_CloseToday;
	ReqOrderInsert(instId,dir,kpp,price,vol,loss);
}